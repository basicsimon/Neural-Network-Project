# -*- coding: utf-8 -*-
"""WNN_AnswersExercise12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fHeV9aKQhZjvhIrevYWhpUX44BFzl9or

Working with Neural Network Models

Â© Hans Nieminen, Satakunta University of Applied Sciences

# Exercise 12.1
"""

import torch
import torch.nn as nn
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader, TensorDataset
import datetime

device = "cuda" if torch.cuda.is_available() else "cpu"
device

# Load the dataset
df = pd.read_csv('https://raw.githubusercontent.com/haniemi/deeplearning/main/data/ZM.csv',
                 usecols=['Date', 'Close'])

df.head()

# Convert the date column to datetime
df['Date'] = pd.to_datetime(df['Date'])

# Sort the data by date
df = df.sort_values('Date')

df.head()

# Normalize the 'Close' price and store mean and std for inverse transform
data = df['Close'].values.astype(float)
data_mean = data.mean()
data_std = data.std()
data_normalized = (data - data_mean) / data_std

data_normalized[:5]

# Generate sequences
def create_sequences(data, seq_length):
    xs, ys = [], []
    for i in range(len(data) - seq_length):
        x = data[i:i + seq_length]
        y = data[i + seq_length]
        xs.append(x)
        ys.append(y)
    return np.array(xs), np.array(ys)

seq_length = 50
x, y = create_sequences(data_normalized, seq_length)

# Convert to PyTorch tensors
x_tensor = torch.tensor(x, dtype=torch.float32).to(device)
y_tensor = torch.tensor(y, dtype=torch.float32).to(device)

# Create DataLoader
dataset = TensorDataset(x_tensor, y_tensor)
dataloader = DataLoader(dataset, batch_size=16, shuffle=False)

class VanillaRNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size,
                 hidden_state_device='cpu'):
        super(VanillaRNN, self).__init__()
        self.hidden_size = hidden_size
        self.rnn = nn.RNN(input_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)
        self.hidden_state_device = hidden_state_device

    def forward(self, x):
        h0 = torch.zeros(1,
                         x.size(0),
                         self.hidden_size).to(self.hidden_state_device)
        out, _ = self.rnn(x, h0)
        out = self.fc(out[:, -1, :])
        return out

input_size = 1
hidden_size = 32
output_size = 1

torch.manual_seed(55)
model = VanillaRNN(input_size, hidden_size, output_size, device).to(device)

# Loss and optimizer
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Training loop
epochs = 100

for epoch in range(epochs):
    for sequences, targets in dataloader:
        sequences = sequences.unsqueeze(-1)  # Add input_size dimension

        outputs = model(sequences)
        loss = criterion(outputs, targets.unsqueeze(-1))

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    if (epoch + 1) % 10 == 0:
        print(f'Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.6f}')

# Generate predictions
model.eval()
with torch.no_grad():
    predictions_normalized = model(x_tensor.unsqueeze(-1)).cpu().numpy()

# Inverse transform the predictions
predictions = predictions_normalized * data_std + data_mean

predictions[:5]

# Plot the results
author = 'Hans Nieminen'
dt = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
plt.figure(figsize=(12, 6))
plt.title(f'{author} {dt}')
plt.plot(y * data_std + data_mean, label='True Data')
plt.plot(predictions, label='Predictions')
plt.legend()
plt.show()

"""# Exercise 12.2 (continue Exercise 12.1)"""

df.tail()

# Predict the stock price for the day after the latest day
with torch.no_grad():
    # Prepare the latest sequence
    latest_sequence = data_normalized[-seq_length:].reshape(1, -1)
    latest_sequence = torch.tensor(latest_sequence, dtype=torch.float32, device=device).unsqueeze(-1)

    # Make the prediction
    prediction_normalized = model(latest_sequence).item()

    # Inverse transform the prediction
    prediction = prediction_normalized * data_std + data_mean

# Print the predicted stock price for tomorrow
print(f'Predicted stock price for tomorrow: {prediction:.3f}')
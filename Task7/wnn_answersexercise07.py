# -*- coding: utf-8 -*-
"""WNN_AnswersExercise07.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W-UgMdg4cb0OcC4xosalWBf4k1T-RFRo

Working with Neural Network Models

Â© Hans Nieminen, Satakunta University of Applied Sciences

# Exercise 7.1

For this exercise use the GPU.
"""

import numpy as np
import torch

torch.manual_seed(222)
t_cpu = torch.randint(-1000, 1001, (100, 1000, 1000))

if torch.cuda.is_available():
    # Move tensor to GPU
    t_gpu = t_cpu.to('cuda')

if torch.cuda.is_available():
    # Compute the mean of all elements in the tensor on the GPU
    tensor_mean_gpu = t_gpu.float().mean()
    # Compute the standard deviation of all elements in the tensor on the GPU
    tensor_std_gpu = t_gpu.float().std()

if torch.cuda.is_available():
    # Move the results back to the CPU
    tensor_mean_cpu = tensor_mean_gpu.to('cpu')
    tensor_std_cpu = tensor_std_gpu.to('cpu')

tensor_mean_cpu

tensor_std_cpu

t1_cpu = torch.cat((tensor_mean_cpu.reshape(1),
                    tensor_std_cpu.reshape(1)),
                   dim=0)
t1_cpu

torch.manual_seed(888)
t2_cpu = torch.randint(1, 11, (10,2))

t2_cpu

product = torch.matmul(t2_cpu.float(), t1_cpu)

product

print(product.numpy().mean().round(2))

"""# Exercise 7.2"""

import numpy as np
import pandas as pd
from sklearn.datasets import load_iris

import torch
from torch.utils.data import Dataset, DataLoader

class Dataset0702(Dataset):
    def __init__(self, X, y, transform=None):
        self.X = X
        self.y = y
        self.transform = transform

    def __len__(self):
        return len(self.y)

    def __getitem__(self, idx):
        input = self.X[idx]
        label = self.y[idx]
        if self.transform is not None:
            for trf in self.transform:
                input = trf(input)
        input = torch.tensor(input, dtype=torch.float32)
        label = torch.tensor(label, dtype=torch.float32)
        return input, label

X, y = load_iris(return_X_y=True)

X[:3]

X.shape

y[:3]

def Squared(x):
    return x**2

def Log(x):
    return np.log(x)

Log(Squared(X))[:3]

transform = [Squared, Log]

transformed_dataset = Dataset0702(X,
                                  y,
                                  transform=transform)

transformed_dataloader = DataLoader(transformed_dataset,
                                    batch_size=16,
                                    shuffle=False)

for batch_idx, (inputs, labels) in enumerate(transformed_dataloader):
    if batch_idx == 7:
        print(f"Transformed Batch {batch_idx + 1}")
        batch8_inputs = inputs
        batch8_labels = labels

batch8_inputs.shape

batch8_inputs

batch8_labels

print(batch8_inputs.numpy()[:,1].mean().round(3))

"""# Exercise 7.3"""

import numpy as np
import torch

vector = [3.2, 2.1, 0.6, 8.3]
x = torch.tensor(vector, requires_grad=True)

# Perform a series of operations on this tensor
y = x * 2
z = y * y * 3
q = z.sum()
out = q.sqrt()

out

print("Tensor x:", x)
print("Tensor y (x * 2):", y)
print("Tensor z (y * y * 3):", z)
print("Tensor q (sum of z):", z)
print("Output (squared root of q):", out)

# Compute the gradient of out with respect to x
out.backward()

# Access and print the gradients
print("Gradients of x:", x.grad)
print("The sum of gradients of x:", x.grad.sum().numpy().round(2))